
Designing Embedded Linux Systems with Python by Mark Kohler

Act 1: Set up the Story
	The Setting
	: Decreasing hardware costs mean that you can build embedded systems with
	: Linux and Python instead of an real-time operating system and C.
		PIC32 (mips 4K, under $10) (slide of DigiKey pricelist)
		RAM (Raspberry Pi slide)
	The Protagonist
	: Embedded programmers face a lot of choices.
	The Imbalance
	: Poor choices extend development time.
	The Balance
	: Choosing wisely maes development easy.
	The Solution
	: Understand the differences between apps and embedded systems.
	
Act 2: Develop the action
	: How?
	:		How?
	:				Why?
	Pick the right distribution.
		The Linux Distribution Ecosystem
			big (kiosk) Ubuntu
			medium Debian
				: Debian official ports
				:	amd64
				:	armel - little-endian ARM
				:	i386
				:	ia64o
				:	mips
				:	mipsel
				:	powerpc
				:	s390
				:	sparc
				:	small Linux from Scratch
		binary vs. source
			continuum: Ubuntu -- Debian -- LinuxFromScratch
			LinuxFromScratch
				cross-compilation, gcc toolchain, unusual platforms
			Debian doesn't support downgrades
				Debian is more granular and more complete than Fedora / RedHat
		custom kernels
		network configuration
			NetworkManager
			: Watch out for NetworkManager. Embedded systems are often
			: not laptops.
			WiFi
		storage and backups
	Pick the right components.
		Plan for upgrades.
			: Storage drives your decisions
			:
			: upgrades: images vs packages vs deployment
			: Leave hooks, controlled by new software.
			: Or better yet, make the new software in charge of upgrades.
			: Worst: Don't allow the upgrade infrastructure to be upgradable.
			: Note: ubuntu's updater gets updated often.
			packaging systems
				Advantages
					already done
				Disadvantages
					designed for end-user systems
					On embedded system, changing stuff in /etc is normal.
					Not for debian.
			filesystem images
			: how big is your partition?
			custom (tarballs)
			The new software must be in control.
		Choose UI libs carefully.
			native UIs (Qt)
			web UI
			native, web, UI
			kiosk model
			: touchscreen
			: Chrome and Firefox have kiosk modes.
		Use external components
			: subprocess
			: swig
			: import multiprocessing
			: pipes
			: C extensions
		Time
			: time zones
			: setting the time
			: time is a bitch
			: story: Ubuntu automatically sets the time when you plug
			: in a network cable.
			:    CMOS time was not getting set.
			:
			:    result: huge time adjustments whenever you plugged in a
			:    network cable.
			:
			:    Conclusion: Avoid time, if possible.
			:
			:    Huge number of time zones.
			:    Don't do timezones. Wristwatches don't.
			:			a story
			:				RTC, system clock
	Write portable code
		Inheritance.
		Types of portability
			: use the car analogy.
			CPU architecture
			hardware architecture
			product varieties
		: the problem: See ifdefs considered harmful
		
		Use abstraction layers.
		Invert the logic
        : Ports should depend on common code 
		: Don't have lots of conditionals in the leaves of your code.
		: Keep the leaves simple.
        : The obvious thing
		: if PRODUCT do this
		: elif PRODUCT2 do that
		: elif PRODUCT2B do that
		Leave hooks.

		Tarpits!
			upgrades
			time
			network configuration

Act 3: Frame the Resolution
	The crisis
	: Complexity overload
	The solution
	: Plan carefully.
	The climax
	The resolution


Good, but where?
	root or not root
		sudo
Trash
	Background
		old way C and RTOS
			cost dev tools, licenses
		new way Linux and Python
		Move from VxWorks/C to Linux/Python
	Make it a screencast.
