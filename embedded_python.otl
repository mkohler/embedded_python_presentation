
Designing Embedded Linux Systems with Python by Mark Kohler

Act 1: Set up the Story
	Setting: Hardware is cheap. RAM is abundant.
	: PIC32 (mips 4K, under $10) (slide of DigiKey pricelist)
	: RAM (Raspberry Pi slide)
	Protagonist: Programmers develop faster with Linux and Python than VxWorks and C.
	: VxWorks stack trace, 
	: cost dev tools, licenses
	Imbalance: Linux distributions are not designed for embedded systems.
	Balance: Develop in Python and create flexible software.
	Solution: Use what you can and use Python to quickly build the rest.
Act 2: Develop the action - How and Why?
	Choose the right distribution.
		: CPU architecture and storage drives your decisions
		The Linux Distribution Ecosystem
			big (kiosk) Ubuntu
			medium Debian
				: Debian official ports
					amd64
					armel - little-endian ARM
					i386
					ia64o
					mips
					mipsel
					powerpc
					s390
					sparc
					small Linux from Scratch
		binary vs. source
			continuum: Ubuntu -- Debian -- LinuxFromScratch
			LinuxFromScratch
				cross-compilation, gcc toolchain, unusual platforms
			Debian doesn't support downgrades
				Debian is more granular and more complete than Fedora / RedHat
		custom kernels
		network configuration
			NetworkManager
			: Watch out for NetworkManager. Embedded systems are often
			: not laptops.
			WiFi
		Choose UI libs carefully.
			native UIs (Qt)
			web UI
			native, web, UI
			kiosk model
			: touchscreen
			: Chrome and Firefox have kiosk modes.
		storage and backups
	Avoid components that assume the desktop.
		Use external components
			: subprocess
			: swig
			: import multiprocessing
			: pipes
			: C extensions
		Time
			: time zones
			: setting the time
			: time is a bitch
			: story: Ubuntu automatically sets the time when you plug
			: in a network cable.
			:    CMOS time was not getting set.
			
			:    result: huge time adjustments whenever you plugged in a
			:    network cable.
			
			:    Conclusion: Avoid time, if possible.
			
			:    Huge number of time zones.
			:    Don't do timezones. Wristwatches don't.
						a story
							RTC, system clock
		root or not root
			: sudo
	Write portable code.
		Plan for upgrades.
			
			: upgrades: images vs packages vs deployment
			: Leave hooks, controlled by new software.
			: Or better yet, make the new software in charge of upgrades.
			: Worst: Don't allow the upgrade infrastructure to be upgradable.
			: Note: ubuntu's updater gets updated often.
			packaging systems
				Advantages
					already done
				Disadvantages
					designed for end-user systems
					On embedded system, changing stuff in /etc is normal.
					Not for debian.
			filesystem images
			: how big is your partition?
			custom (tarballs)
			The new software must be in control.
		Inheritance.
		Types of portability
			: use the car analogy.
			CPU architecture
			hardware architecture
			product varieties
		: the problem: See ifdefs considered harmful
		Use abstraction layers.
		Invert the logic
		: Ports should depend on common code 
		: Don't have lots of conditionals in the leaves of your code.
		: Keep the leaves simple.
		: The obvious thing
		: if PRODUCT do this
		: elif PRODUCT2 do that
		: elif PRODUCT2B do that
		: Leave hooks.
		Tarpits!
			upgrades
			time
			network configuration
Act 3: Frame the Resolution
	Crisis: Complexity overload
	Solution: Plan carefully.
	Climax:
	Resolution:
