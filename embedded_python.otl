
Designing Embedded Linux Systems with Python by Mark Kohler

Act 1: Set up the Story
	Setting: Hardware is cheap. RAM is abundant.
	: PIC32 (mips 4K, under $10) (slide of DigiKey pricelist)
	: RAM (Raspberry Pi slide)
	Protagonist: Programmers develop faster with Linux and Python than VxWorks and C.
	: VxWorks stack trace, 
	: cost dev tools, licenses
	Imbalance: Linux distributions are not designed for embedded systems.
	Balance: Develop in Python and create flexible software.
	Solution: Use what you can and use Python to quickly build the rest.
Act 2: Develop the action - How and Why?
	Choose the right distribution.
		Choose Ubuntu for a kiosk.
		: CPU: amd64, i386, arm
		: Storage: 15GB
		: Packages more complete than Fedora / RedHat
		: Chrome and Firefox have kiosk modes.
		Choose Debian for an appliance.
		: CPU: amd64, armel, i386, ia64o,  mips, mipsel, powerpc, s390, sparc
		: Storage: 1GB
		For a thermostat, start with BusyBox and Linux from Scratch.
		: CPU: http://en.wikipedia.org/wiki/List_of_Linux_supported_architectures
		: Packages more granular than Fedora / RedHat
		: cross-compilation, gcc toolchain, unusual platforms, custom kernels
		: You are doing platform development.
	Eliminate desktop assumptions.
		Plan for upgrades.
			python-apt
			: Debian doesn't support downgrades
			
			: upgrades: images vs packages vs deployment
			: Leave hooks, controlled by new software.
			: Or better yet, make the new software in charge of upgrades.
			: Worst: Don't allow the upgrade infrastructure to be upgradable.
			: Note: ubuntu's updater gets updated often.
			packaging systems
				Advantages
					already done
				Disadvantages
					designed for end-user systems
					On embedded system, changing stuff in /etc is normal.
					Not for debian.
			filesystem images
			: how big is your partition?
			custom (tarballs)
			The new software must be in control.
		Time
			: time zones
			: setting the time
			: time is a bitch
			: story: Ubuntu automatically sets the time when you plug
			: in a network cable.
			:    CMOS time was not getting set.
			
			:    result: huge time adjustments whenever you plugged in a
			:    network cable.
			
			:    Conclusion: Avoid time, if possible.
			
			:    Huge number of time zones.
			:    Don't do timezones. Wristwatches don't.
						a story
							RTC, system clock
		Root is okay.
			: sudo is okay too.
		Don't manage NetworkManager.
			: Configure networks like servers, not clients.	
	Write portable code.
		Use external components
			: subprocess
			: swig
			: import multiprocessing
			: pipes
			: C extensions
		Inheritance.
		Types of portability
			: use the car analogy.
			CPU architecture
			hardware architecture
			product varieties
		: the problem: See ifdefs considered harmful
		Use abstraction layers.
		Invert the logic
		: Ports should depend on common code 
		: Don't have lots of conditionals in the leaves of your code.
		: Keep the leaves simple.
		: The obvious thing
		: if PRODUCT do this
		: elif PRODUCT2 do that
		: elif PRODUCT2B do that
		: Leave hooks.
		Tarpits!
			upgrades
			time
			network configuration
Act 3: Frame the Resolution
	Crisis: Complexity overload
	Solution: Plan carefully.
	Climax:
	Resolution:
