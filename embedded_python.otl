
Designing Embedded Linux Systems with Python by Mark Kohler

Act 1: Set up the Story
	Setting: Hardware is cheap. RAM is abundant.
	: PIC32 (mips 4K, under $10) (slide of DigiKey pricelist)
	: RAM (Raspberry Pi slide)
	Protagonist: Programmers develop faster with Linux and Python than VxWorks and C.
	: VxWorks stack trace, 
	: cost dev tools, licenses
	Imbalance: Linux distributions are not designed for embedded systems.
	Balance: Develop in Python and create flexible software.
	Solution: Use what you can and use Python to quickly build the rest.
Act 2: Develop the action - How and Why?
	Choose the right distribution.
		Choose Ubuntu for a kiosk.
		: CPU: amd64, i386, arm
		: Storage: 15GB
		: Packages more complete than Fedora / RedHat
		: Chrome and Firefox have kiosk modes.
		: Using Ubuntu can be the quickest path to a working kiosk.
		: on ragged edge for support libraries
		Choose Debian for an appliance.
		: CPU: amd64, armel, i386, ia64o,  mips, mipsel, powerpc, s390, sparc
		: Storage: 1GB
		: some support for cross-compilation with emdebian project.
		For a thermostat, start with BusyBox and Linux from Scratch.
		: CPU: http://en.wikipedia.org/wiki/List_of_Linux_supported_architectures
		: Packages more granular than Fedora / RedHat
		: cross-compilation, gcc toolchain, unusual platforms, custom kernels
		: You are doing platform development.
	Eliminate desktop assumptions.
		: For Ubuntu and Debian.
		Handle upgrades automatically.		
			: Upgrading software should control the process.
			Simplest approach Using filesystem images or tarballs
			: Ideal for small systems that run out of RAM.
			: Ping-pong approach can also work.
			: Problem for large systems.
			Using apt
			: python-apt supports custom interfaces.
			: Debian doesn't support downgrades
			: /etc is a problem.
			: Watch out for debconf questions.
		Be wary of time-related code.
			: Time
			: Avoid time zones, if possibles. Wristwatches do.
			: setting the time
			: time is a bitch
			: story: Ubuntu automatically sets the time when you plug
			: in a network cable.
			:    CMOS time was not getting set.
			:    result: huge time adjustments whenever you plugged in a
			:    network cable.
			:    Conclusion: Avoid time, if possible.
			:    Huge number of time zones.
			:    Don't do timezones. Wristwatches don't.
		Root is okay.
			: **** need why or why not
			: sudo is okay too. write privileged programs in python
		Don't manage NetworkManager.
			: Configure networks like servers, not clients.	
	Write portable code.
		What is portable code?
		: There is more than one type of portability.
		:
		: 
			luxury edition
		Types of portability
			: use the car analogy.
			CPU architecture
			hardware architecture
			product varieties
		: the problem: See ifdefs considered harmful
		Inheritance.
		Use abstraction.
		Use composition instead of inheritance
		Fisrt separate common and model-specific code.
		Who likes frameworks?
		Who prefers libraries?
		similar to switching from framework to library.
		Don't depend on details. Depend on commonalities.
		: Ports should depend on common code 
		: Don't have lots of conditionals in the leaves of your code.
		: Keep the leaves simple.
		: The obvious thing
		: if PRODUCT do this
		: elif PRODUCT2 do that
		: elif PRODUCT2B do that
		Use external components
			: subprocess
			: swig
			: import multiprocessing
			: pipes
			: C extensions
			: Zero
Act 3: Frame the Resolution
	Crisis: Complexity overload
	Solution: Plan carefully.
	Climax:
	Resolution: Create embedded systems. Use Linux. Use Python.
