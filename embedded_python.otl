
Designing Embedded Linux Systems for Python Programmers
by Mark Kohler

Act 1: Set up the Story
	Setting: Hardware is cheap.
	: The price difference between 8-bit and 32-bit processors is small and
	: dwindling. (Raspberry Pi slide)
	:
	: There are a wide variety of embedded systems, with great differences
	: between them. To try and cover this range, I'm going to use 3 examples.
	: 3 embedded system examples
	: 	kiosk, like an ATM
	: 	home router
	: 	thermostat
	Protagonist: My premise is that programmers develop faster with Linux and
	Python than a micro-controller operating systems and C.
	: better tools, better documentation (the source!), and a higher-level
	: language
	Imbalance: The problem is, Linux distributions are not designed for embedded systems.
	Balance: We want to develop in Python and create flexible software quickly.
	Solution: Use what you can from the distribution and use Python to build the rest.
Act 2: Develop the action - How and Why?
	Choose the right distribution.
		For a kiosk, choose Ubuntu.
			A kiosk is the almost most like a desktop.
			: CPU: amd64, i386, arm
			: Storage: 15GB
			: 	There's a screen, an x86 processor, and a pointing device.
			: Some differences:
			: 	only one application
			: 	no administrator - all configuration must be automatic
			: 	no user login
			Using Ubuntu can be the quickest path to a working kiosk.
			: Ubuntu has great support for Linux desktops.
			: Chrome and Firefox have kiosk modes.
			: You can write your user interface software for a browser, or you
			: have a wide choice of toolkits like Qt and GTK.
			Why not Fedora?
			: Ubuntu is based on Debian and the Debian project has packaged a
			: lot more software than Fedora. So it is more likely that the
			: software you want is already packaged.
			:
			: Further, the packages are more granular, so if you are tight on
			: space, it is much easier to slim down your storage requirements,
			: by just removing packages.
		For a home router, choose Debian.
			Debian supports more processors than Ubuntu
			: CPUs amd64, armel, i386, ia64o,  mips, mipsel, powerpc, s390, sparc
			Debian requires less storage.
			: Storage: 1GB
			Debian has some support for cross-compilation with emdebian project.
			Why not Ubuntu?
			: Ubuntu is always shipping core components (boot support,
			: filesystems, libraries) that are on the ragged edge, usually to
			: support something new for desktop users. The best example of this
			: is the effort that has gone into supporting 3D desktop features.
			:	
			:  All of the fancy desktop features from Ubuntu aren't going to
			:  help, might get in the way, and reduce stability.
		For a thermostat, start with BusyBox and Linux from Scratch.
			: CPU: http://en.wikipedia.org/wiki/List_of_Linux_supported_architectures
			What is BusyBox?
			: BusyBox is a very small user-space implementation for Linux
			What is Linux from Scratch?
			: Linxu from Scratch and its companion Cross Linux from Scratch
			: are book-based distributions that explain issues like:
			: 	creating and use a cross-compilation toolchain
			: 	building custom kernels
			:	using unusual boot loaders
			:	customizing the boot process
	Eliminate desktop assumptions
		: For Ubuntu and Debian. 
		: For BusyBox, this has either been done for you, or you've created
		: everything yourself.
		Handle upgrades automatically.		
			Simplest approach: script and filesystem image
			: Ideal for small systems that run out of RAM.
			: step 1 - running system downloads a script
			: step 2 - script downloads a filesytem image and writes it to
			: secondary storage
			: step 3 - reboot
			: details - migrate settings forward, configuration partition
			Ping-Pong
			: for systems that run off of secondary storage
			: You have two partitions that each contain a complete system.
			: boot from 1 partition, upgrade the other, toggle the bootloader.
			: downsides
			: 	need enough space for two system images.
			: 	need to be able to download a complete system image
			Using apt
			: Most complicated approach because of inherent assumptions
			: 	- If an package doesn't know what to do, it can appeal to a
			: 	human for help.
			: 	- The human administrator is responsible for configuration, and only with
			: 	the administrator's approval can packages change the
			: 	configuration.
			: 	
			: python-apt supports custom interfaces.
			: Debian doesn't support downgrades
			: /etc is a problem.
			: Watch out for debconf questions.
			:
			: Solutions:
			: 	Automate using python-apt library.
			: 	Careful testing.
			: 	Pre-seeding with debconf.
			General Principle: Upgrading software should control the process.
		Be wary of code related to dates and times.
			This is an area notorious for bugs.
				This year, Microsoft's cloud computing platform had an unusal amount of downtime on...Feb 29.
				Y2K.
				GPS time vs UTC time
				: GPS time does not use leap seconds - different by 15 seconds
				Linux: elapsed time vs. clock time
				: Linux does not support elapsed time. Applications get the
				: system time and do their own calculations.
				:
				: T2 - T1 does not equal elapsed time
				:
				: settimeofday
				Linux: seconds are not constant
				: Under half a second
				: See adjtimex(2)
				Linux: time is not monotonic
				: For more than a half a second, system time can jump forward
				: or back
				:
				: Affects timeouts
				: cron jobs
			
			: Time
			: Avoid time zones, if possibles. Wristwatches do.
			: setting the time
			: time is a bitch
			: story: Ubuntu automatically sets the time when you plug
			: in a network cable.
			:    CMOS time was not getting set.
			:    result: huge time adjustments whenever you plugged in a
			:    network cable.
			:    Conclusion: Avoid time, if possible.
			:    Huge number of time zones.
			:    Don't do timezones. Wristwatches don't.
		Don't manage NetworkManager.
			: Configure networks like servers, not clients.	
		sudo is the new setuid
			: In the desktop world, in the website world, you don't run your
			: software as root.
			:
			: **** need why or why not
			: sudo is okay too. write privileged programs in python
	Write portable code.
		: We talked about Linux. Now we can talk about Python.
		:
		: And I want to talk about a particular aspect of program design that
		: is especially important to embedded systems software.
		:
		: I want everyone to write portable code in Python.
		What is portable code? Isn't Python portable?
		: I've never seen endian macros in Python code.
		: I haven't seen near and far pointers.
		: I haven't seen 36-bit words.
		:
		: Yes, Python is portable across *processors*.
		: There is more than one type of portability.
		Types of portability
		: The kind of portability I'm talking about is using one source base
		: across a range of products, which is very common in embedded
		: systems.
		:
		: You need to support a common core of functionality, but with
		: somewhat varying features, and varying hardware platforms.
		:
		: Hardware: Different sensors, different network interfaces, etc.
		: On the feature side, marketing says there should be a a basic model, and a
		: luxury or professional model.
		The naive approach	
			: Python has support for this. It is called the if statement. You
			: just write your code and when you get to a difference between
			: the models you write:
			; if PRODUCT_A do this
			; elif PRODUCT_B do that
			; elif PRODUCT_C do something else
			That works. So what's the problem?
				: The problem is the number of code paths increases with each product.	
				:
				: The complexity increases.
				:
				: And when you're working on the software, regardless of which
				: product you are working on, you see the complexity of the sum
				: total of all the products.
				:
				: Another problem is that the differences between products are
				: hidden in the leaves of your code.
				:
				: Stop and talk about trunk vs. leaves.
				:
				: By that, I mean, 
				:
				: If any of you have programmed in C, C has two different
				: kinds of if statements: the kind that evaluate at compile-time
				: and the kind that evaluate at run-time.
				: 
				: See #ifdef Considered Harmful by Henry Spencer
				:
				Is a program written this way modular? Let's come back to that.
			Separate common and model-specific code.
			: So we're using this "if" statement, and we're starting to
			: feel like we're losing.
			:
			: We'd really like to be able to work on the core code, without
			: seeing the complexity of all of the product varieties.
			:
			: I can use abstraction. Draw a circle around the leaves.
			: This is Better
			: But let's ask again, is this program modular?
			:
			: We have these leaves of code that contain 
			:
			: We contained the complexity, but we're not reducing it:
			: 	The common parts of the software depends on these leaves that
			: 	keep getting more and more complex.
			:
			: In 1972, David Parnas wrote a paper called "On the Criteria To
			: Be Used in Decomposing Systems into Modules". And he said:
			:
			: "We propose instead that one begins with a list of difficult
			: design decisions or design decisions which are likely to change.
			: Each module is then designed to hide such a decision from the
			: others."
			:
			: In our program, what are we hiding?
			:
			: We are hiding the model-specific code from the core code, and
			: that's code. But the model-specific code is all mixed together.
			:
			: We want to *hide* the differences, the parts of the program that
			: have changed before, and thus are likely to change again, from
			: the other parts of the software.
			:
			: Another problem. We have these interfaces between the core code
			: and the model-specific code. Are they stable? By that, I mean,
			: do they remain the same over time? Or do we need to
			: change them every time we add a new model?
		Question for the audience: Who likes frameworks? Who prefers libraries?
		Best
			There is a solution. Turn the call-graph inside out.
			: Differences are often in setup and teardown. So let the
			: model-specific code call the common code.
			Don't depend on details. Depend on commonalities.
			: Ports should depend on common code 
			: Don't have lots of conditionals in the leaves of your code.
			: Keep the leaves simple.
			: The obvious thing
			Explain why it is better:
				Details of strange hardware are hidden.
			Better for testing.
				Differences between hardware are easy to see.
Act 3: Frame the Resolution
	Crisis: Developing embedded systems with C is slow.
	Solution: Use Linux where you can, and use Python for the rest.
	Climax: Writer better embedded systems faster.
	Resolution: Questions?
